/**
 * @param {Uint8Array} bin
 * @param {number} start
 * @param {number} end
 * @returns {string}
 */
function binToRaw (bin, start, end) {
  if (!(bin instanceof Uint8Array)) bin = new Uint8Array(bin);
  start = start == null ? 0 : start | 0;
  end = end == null ? bin.length : end | 0;
  let raw = '';
  for (let i = start || 0; i < end; i++) {
    raw += String.fromCharCode(bin[i]);
  }
  return raw;
}

// This takes nested lists of numbers, strings and array buffers and returns
// a single buffer.  Numbers represent single bytes, strings are raw 8-bit
// strings, and buffers represent themselves.
// EX:
//    1           -> <01>
//    "Hi"        -> <48 69>
//    [1, "Hi"]   -> <01 48 69>
//    [[1],2,[3]] -> <01 02 03>
/**
 * @param {any} parts
 * @returns {Uint8Array}
 */
function flatten (parts) {
  if (typeof parts === 'number') return new Uint8Array([parts]);
  if (parts instanceof Uint8Array) return parts;
  if (parts instanceof ArrayBuffer) return new Uint8Array(parts);
  let buffer = new Uint8Array(count(parts));
  copy(buffer, 0, parts);
  return buffer;
}

function count (value) {
  if (value == null) return 0;
  if (typeof value === 'number') return 1;
  if (typeof value === 'string') return value.length;
  if (value instanceof Uint8Array) return value.length;
  if (value instanceof ArrayBuffer) return value.byteLength;
  if (!Array.isArray(value)) {
    print('VALUE', value);
    throw new TypeError('Bad type for flatten: ' + typeof value);
  }
  let sum = 0;
  for (let piece of value) {
    sum += count(piece);
  }
  return sum;
}

function copy (buffer, offset, value) {
  if (value == null) return offset;
  if (typeof value === 'number') {
    buffer[offset++] = value;
    return offset;
  }
  if (typeof value === 'string') {
    for (let i = 0, l = value.length; i < l; i++) {
      buffer[offset++] = value.charCodeAt(i);
    }
    return offset;
  }
  if (value instanceof ArrayBuffer) {
    value = new Uint8Array(value);
  }
  for (let piece of value) {
    offset = copy(buffer, offset, piece);
  }
  return offset;
}

/**
 * indexOf for arrays/buffers.  Raw is a string in raw encoding.
 * returns -1 when not found.
 * start and end are indexes into buffer.  Default is 0 and length.
 * @param {Uint8Array} bin
 * @param {string} raw
 * @param {number} start
 * @param {number} end
 * @returns {number}
 */
function indexOf (bin, raw, start, end) {
  /* eslint-disable no-labels */
  start = start == null ? 0 : start | 0;
  end = end == null ? bin.length : end | 0;
  outer: for (let i = start || 0; i < end; i++) {
    for (let j = 0, l = raw.length; j < l; j++) {
      if (i + j >= end || bin[i + j] !== raw.charCodeAt(j)) {
        continue outer;
      }
    }
    return i;
  }
  return -1;
}

export { binToRaw, flatten, indexOf };
